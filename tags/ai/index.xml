<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>AI on Wsl Blog</title>
    <link>/tags/ai/</link>
    <description>Recent content in AI on Wsl Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 15 Jul 2016 08:29:06 -0700</lastBuildDate>
    
	<atom:link href="/tags/ai/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Fun With Dijkstra Mapping</title>
      <link>/posts/2016-07-15-fun-with-dijkstra-mapping/</link>
      <pubDate>Fri, 15 Jul 2016 08:29:06 -0700</pubDate>
      
      <guid>/posts/2016-07-15-fun-with-dijkstra-mapping/</guid>
      <description>Continuing in my never-ending project to make a &amp;ldquo;simple&amp;rdquo; roguelike in C++, I decided to tackle something I have never before tried: artificial intelligence. My first rough idea was to implement some sort of component-type system, and build the AI up like I built up entities. This turned out to be far too complicated, and even getting a monster to move randomly was a chore. Obviously, this wasn&amp;rsquo;t going to work.
After browsing /r/roguelikedev and RogueBasin I came across a few articles on &amp;ldquo;need driven AI&amp;rdquo; - an absurdly cool concept, and so (seemingly) simple to implement I wasn&amp;rsquo;t sure how I didn&amp;rsquo;t stumble across this earlier. Basically, creatures in the game assign a value to things they know about (treasure, the player, exits, other monsters they are friendly with, other monsters they are terrified of, etc. etc.) and make an &amp;lsquo;informed&amp;rsquo; decision about where to move next. A monster could desire killing the player over treasure, and would &amp;ldquo;decide&amp;rdquo; to move towards the player instead of a closer pile of gold. Maybe that monster is a pack hunter, and also strongly desires to be near it&amp;rsquo;s pack - so when singled out it moves away to regroup with others. Cats could hunt mice, the undead could wander aimlessly attacking anything, golems could guard exits, archers could stay a safe distance away, and
&amp;hellip;
Clearly, this idea has so many uses that I absolutely had to attempt an implementation in my game. The best article I found describing what I hope to accomplish was written by the creator of the awesome Brogue, and talked about something called &amp;ldquo;Dijkstra mapping.&amp;rdquo; A number on a Dijkstra map is the shortest distance from that tile to the goal. Moving from any numbered tile to any lower numbered tile adjacent will take you on the shortest path to the goal. Using this technique I could also accomplish intelligent pathfinding (another thing I&amp;rsquo;ve never been quite able to do on my own). So,	the first step was to write up something to generate these maps.
After much confusion (I&amp;rsquo;m still not much of a C++ programmer), I ended up with a fairly simple and straightforward set of code to generate a vector of integers representing a Dijkstra map from the vector of integers representing a normal dungeon map.</description>
    </item>
    
  </channel>
</rss>