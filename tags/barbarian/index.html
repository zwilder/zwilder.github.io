<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Barbarian! | Wsl Blog</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    <link rel="icon" type="image/svg+xml" href="/wsl.svg" />
    <link href="https://fonts.googleapis.com/css?family=Cinzel+Decorative|Raleway&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Belgrano|Lato&display=swap" rel="stylesheet">



<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>


<script>
jQuery(document).ready(function($) {
    
        
    
    $('.ltbox-trigger').click(function(e) {
    	
        
		e.preventDefault();
		
		
		var image_href = $(this).attr("href");
		
		

		
		if ($('#ltbox').length > 0) { 
			
			
			$('#content').html('<img src="' + image_href + '" />');
		   	
			
			
            
            $('#ltbox').toggle();
		}
		
        return false;
    });
    $('body').on('click', '#ltbox', function() { 
        
        $('#ltbox').toggle();
    });
});
</script>

  </head>

  <body>
      <div class="site-title">
          <img class="wsl-logo" src="/wsl.svg" />
          <span class="wsl-title">
             Wsl Blog
          </span>
      </div>
    <nav>
    <p class="sub-title">Adventures in making, arting, exploring, and other things.</p>
    <div class="menu">
        <ul>
          
              <li><a href="/">Home</a></li>
          
              <li><a href="/posts/">Archive</a></li>
          
              <li><a href="/categories/">Categories</a></li>
          
              <li><a href="/tags/">Tags</a></li>
          
              <li><a href="/subscribe/">Subscribe</a></li>
          
              <li><a href="/index.xml">RSS</a></li>
          
        </ul>
    </div>
    <hr/>
    </nav>


<div class="article-meta">
    <div class="title"><span>Barbarian!</span></div>
</div>
    <hr/>
<main>
    

    
        <div class="list-article">
            
            
            <div class="list-title"><a href="/posts/2018-09-18-explosions/">Explosions in the Dungeon</a></div>
            
                <span class="list-author">Zach Wilder</span>
            
            
                <span class="list-date"> - 18 Sep 2018</span>
            
            <p class="list-summary">
            One of the big goals for Barbarian and one of the coolest things on my to do list was to add animations into the game. How exciting is it to see an arrow flying toward your character, a firebolt explode in the face of an undead horde, blood splatter flying from the wounds inflicted by the mighty barbarian decorating the walls of the dungeon?
Obviously, the excitement added by all these visual effects is well worth the time spent adding them in. I started thinking about how I wanted to incorporate animations during the Tutorial Tuesday Challenge, and started jotting implementation ideas down in my notebook almost two months ago. For the life of me I could not find a good writeup on creating procedural explosions on a 2d grid, and could not wrap my head around how to make them look decent. I shared my struggles on the r/roguelikedev sharing Saturday post, and another dev (u/darkgnostic) gave me some fantastic ideas about reusing my line-of-sight code. So, armed with this knowledge I sat down last week and decided to finally try some of my implementation ideas.
The idea was simple, for each frame expand outward from the origin of the explosion to a set radius.
The Framework In order to test this out, I needed to actually get the animations working. Like most bits of code that I only have a vague idea of how to accomplish I started at the top: Engine::update() and Engine::draw() should loop through a list of animations, updating and drawing them. Easy enough to draw them, just need an Animation::draw() routine. Update would be similar, but would need to know how much time had passed since the last update. To get this, I needed to visit the main loop code
 something that hasn&rsquo;t been looked at in quite a while.  Cracked open main.cpp, dusted it off and examined my loop. Previously the game was limited to 60fps by using a call to sleep the thread - definitely gross and in need of some work. Where had I seen a beautiful, simple game loop before?
                
                  <br/>
                  <a href="/posts/2018-09-18-explosions/">
                    [Read more]
                  </a>
                
            </p>
        </div>
    
        <div class="list-article">
            <hr class="list-break" \>
            
            <div class="list-title"><a href="/posts/2018-08-26-lists/">Wonderful Lists</a></div>
            
                <span class="list-author">Zach Wilder</span>
            
            
                <span class="list-date"> - 26 Aug 2018</span>
            
            <p class="list-summary">
            Over the course of the 2018 r/roguelikedev Tutorial Tuesday Challenge I decided to invest some time learning some fundamental programming concepts that I probably should have learned years ago. The fun (and challenging) part of being a hobby programmer is that most of my learning comes from books, and then random tutorials on the internet. Somewhere in the course of my &ldquo;education&rdquo; I never learned about basic data structures and how they can be used.
Around week three of the challenge I decided to implement a scheduling system for Barbarian - which led me to learn about creating lists and priority queues. STL has std::priority_queue, but like many STL classes never seems to want to play nicely with my code. Again, likely a byproduct of me learning C++ from a book and probably not the fault of STL.
This is my very first attempt at writing a tutorial - expect some errors and feel free to comment with any corrections. I will absolutely guarantee that there is probably a better way of doing what I&rsquo;ve written here, so don&rsquo;t read this as gospel.
Making a List A list is a fantastic data structure - and is so simple to implement I&rsquo;m not sure why it was never included in the beginning programming books I have read. A list is an ordered collection of nodes, where each node has some data and a pointer to the next node. The list has a head and a tail - the very first and very last nodes in the list. That&rsquo;s it! That&rsquo;s all they are.
Head A ---&gt; B ---&gt; C &lt;- Node 1 2 3 &lt;- Data Tail Definining a node is simple, and using the power of C++ templates you can make a node hold any data you can imagine!
template &lt;typename T&gt; class Node { public: Node(T d) : data(d) { next = NULL; prev = NULL; } T data; Node * next; Node * prev; };  Then to create the list all we need is a couple of functions - one to add nodes and one to remove nodes.
                
                  <br/>
                  <a href="/posts/2018-08-26-lists/">
                    [Read more]
                  </a>
                
            </p>
        </div>
    
        <div class="list-article">
            <hr class="list-break" \>
            
            <div class="list-title"><a href="/posts/2018-08-09-the-rogueliketutorial-week7/">The Roguelike Tutorial - Week 7</a></div>
            
                <span class="list-author">Zach Wilder</span>
            
            
                <span class="list-date"> - 9 Aug 2018</span>
            
            <p class="list-summary">
            I didn&rsquo;t do a lot of coding over the last week, but I did finish the challenge! Had a bit of a scare after finishing part 12, I found a horrible lurking bug in the program that caused a LOT of little errors and I wasn&rsquo;t sure (at first) how to track it down. Basically, shortly after finishing adding in some cool randomization functions I found that some entities weren&rsquo;t being copied correctly, or saved correctly. Turns out, the C++ Rule of 3/5/0 is actually a rule and not just a suggestion/guideline.
This project was the first time I attempted to use smart pointers and write more &ldquo;correct&rdquo; C++ code, and apparently even when using smart pointers to allocate memory you should write at least a copy constructor and copy assignment function. I&rsquo;m still not sure what I would put in a custom destructor if all the memory that&rsquo;s allocated is done via smart pointers, and that might be something I need to clean up now the challenge is over.
When the Entity class was created with the default copy constructor (or copy assignment), it wasn&rsquo;t allocating new memory for the new entity. So, when one entity was destroyed another entity would suddenly lose it&rsquo;s components! This never was a problem before part 12, because I never tried to duplicate entities. One of the main goals in part 12 was to intelligently place monsters, and I implemented that with a weighted list that contained a prototype entity which was duplicated each time one of those enemies was placed. All of a sudden, enemies suddenly couldn&rsquo;t die after the first one was killed. Pathfinding spontaneously broke. Entity names started being displayed as gibberish. I seriously thought I was going to have to scrap the project at this point, because I had no idea where to begin solving this problem. The answer eventually came to me at work, and getting everything smoothed out was pretty trivial.
Part 12 So the theme of part 12 was to start implementing more randomization functions. Up until this week I was using the built in STL version of mersenne twister, and I don&rsquo;t think the way I was using it was the most effective or how it was designed to be used.
                
                  <br/>
                  <a href="/posts/2018-08-09-the-rogueliketutorial-week7/">
                    [Read more]
                  </a>
                
            </p>
        </div>
    
        <div class="list-article">
            <hr class="list-break" \>
            
            <div class="list-title"><a href="/posts/2018-07-31-the-roguelike-tutorial-week5b6/">The Roguelike Tutorial - Week 5b/6</a></div>
            
                <span class="list-author">Zach Wilder</span>
            
            
                <span class="list-date"> - 31 Jul 2018</span>
            
            <p class="list-summary">
            Oh man, this has been a super exciting and productive week - this project is starting to feel like a real game! Started off last week a bit behind schedule, having just finished part 8. After my rant last week about my source code files getting too long, I decided to spend a bit of time going back over my core classes and cleaning up the code. I also split Engine into multiple files - which ended up making a lot of things a lot easier. Heck, recompiling a huge source file each time I make a minor change was tedious, and the time savings alone was worth splitting the files. Each of the Engine main functions now has it’s own file, and then each of those main functions calls separate routines depending on what GameState the game is in. Each of those separate, state specific functions has its own file. Code that’s reused between routines lives in the main function file.
I think it’s pretty cool - makes finding and changing things easier. I also noticed that this project is now more than twice the length (lines of code) of any project I’ve done so far. This weeks post was originally intended to cover just part 9, but I threw 10 and 11 in as well since they were relatively short.
Part 9 - Targeting I wasn’t sure when I started this part how I would go about doing it. Style-wise, I like the way ADOM and Angband handling targeting with the auto select target and keyboard interface. Using a mouse feels weird to me when playing roguelikes, so I knew I didn’t want to stick to the ideas in the Python tutorial. The game engine is already set up to handle different game states, but targeting isn’t really a state - more of a miniature loop with it’s own events and draw cycle.
So, I decided to make targeting exactly that - a game state that isn’t really a state, but a miniature replica of the main game loop. When a function (any function) calls Engine::target() the game saves the current state, and starts it’s own loop.
                
                  <br/>
                  <a href="/posts/2018-07-31-the-roguelike-tutorial-week5b6/">
                    [Read more]
                  </a>
                
            </p>
        </div>
    
        <div class="list-article">
            <hr class="list-break" \>
            
            <div class="list-title"><a href="/posts/2018-07-24-the-roguelike-tutorial-week5a/">The Roguelike Tutorial - Week 5a</a></div>
            
                <span class="list-author">Zach Wilder</span>
            
            
                <span class="list-date"> - 24 Jul 2018</span>
            
            <p class="list-summary">
            Another very productive week for this project! Although I was unable to finish last weeks goals of getting Parts 8 and 9 completed by today, I still feel pretty darn good about what I did accomplish. Besides, Parts 10, 11, and 12 are all fairly simple - heck the code is already in place, just needs to actually be used!
After finishing Part 7 last week I decided to try and fix/change a few things that have been bothering me. The square, 12x12 font, looked great for the map tiles but it was really ugly for text. I figured my alternatives were to either use two fonts (like a 6x12 for text and a 12x12 for map), or just use a different font altogether. All my years playing games in a terminal window pushed me to the second option - if it’s good enough for the best roguelikes, it’s good enough for me! The only difficulty with this option is that if I ever want to add graphical tiles easily, I’d have to make the tiles in a strange size (ie 9x14 instead of 16x16). Adding graphical tiles in will be a chore anyways, so I’ll just go ahead and not worry about it now. This is what the game looks like now:
  Pretty slick! After changing to a nice 9x14 font, I decided to tackle another minor improvement that makes a huge impact: fullscreen mode! First, I had to set the game window to a standard resolution (800x600), and then center the console in that window. Easy enough. Conveniently SDL has a super cool built in function to turn on fullscreen! Oddly, it doesn’t work at all. Maybe a fault with my code, maybe a fault with SDL. Not sure, but google showed me that a bunch of people have the same issue - and very few people had work-arounds. The solution I chose to go with is to make the window a bit larger than the computer desktop resolution, and then center it. So, it’s very much a fake fullscreen, but it works and looks darn nice.
                
                  <br/>
                  <a href="/posts/2018-07-24-the-roguelike-tutorial-week5a/">
                    [Read more]
                  </a>
                
            </p>
        </div>
    
        <div class="list-article">
            <hr class="list-break" \>
            
            <div class="list-title"><a href="/posts/2018-07-18-the-roguelike-tutorial-week4/">The Roguelike Tutorial - Week 4</a></div>
            
                <span class="list-author">Zach Wilder</span>
            
            
                <span class="list-date"> - 18 Jul 2018</span>
            
            <p class="list-summary">
            The past week has been equal parts frustration and excitement with this project. I ran into a pretty common design problem: entity components need to know about the rest of the game. Well, since each entity is just a collection of components it shouldn&rsquo;t be difficult to pass a pointer to the game engine. Then, the components would have a pointer to the entity that &ldquo;owns&rdquo; it. Simple and clean&hellip; or so I thought. This didn&rsquo;t work, at all. Individual entities could access the engine just fine, but the components just could not access anything about their owner. Even trying to print the address of the owner caused the game to segfault and crash. GDB was no help, and I tried MANY things to get this to work.
I realized that I was bashing my head against this problem, and totally stumped, so I decided to work on something else. I changed the Engine&rsquo;s entity list from a std::vector&lt;Entity&gt; to a wsl::DLList&lt;Entity&gt; (from the fancy list class I created last week). To my surprise and delight, it worked perfectly! What&rsquo;s nice about using the list I created is that it manages it&rsquo;s own memory - I don&rsquo;t have to worry about allocations/deallocations no matter how big the list gets!
This got me thinking about best practices and clean code again. In general, I&rsquo;ve heard you should always use the Standard Template Library containers over a custom rolled solution. However, I know my code, I know how it works, and I can fix/change it with minimal fuss. Creating a custom wrapper for std::priority_queue or std::map? No way, I have no idea where to even begin!
So, with this in mind I returned to my original problem. To hell with best practice, I&rsquo;m not a professional and I don&rsquo;t work with other programmers. My code is written clearly and commented well, so it should be easy to figure out why I did things the way I did. I decided that a good, bare bones, no frills system has components that are nothing more than data containers, and entities that are collections of components.
                
                  <br/>
                  <a href="/posts/2018-07-18-the-roguelike-tutorial-week4/">
                    [Read more]
                  </a>
                
            </p>
        </div>
    
        <div class="list-article">
            <hr class="list-break" \>
            
            <div class="list-title"><a href="/posts/2018-07-10-the-roguelike-tutorial-week3b/">The Roguelike Tutorial - Week 3b</a></div>
            
                <span class="list-author">Zach Wilder</span>
            
            
                <span class="list-date"> - 10 Jul 2018</span>
            
            <p class="list-summary">
            I originally planned for this week&rsquo;s blog post to cover my adaptation of part 5 of the Python RL tutorial - but after finishing part 5 in a matter of minutes I realized there wouldn&rsquo;t be much to write here! Part 5 is basically making new entities and getting the collision logic in place before combat is added in part 6. However, before adding combat I thought it would be beneficial to start thinking about game time - it&rsquo;s far more fun when some enemies are a lot quicker than the player, forcing the player to devise strategies for survival.
Naturally, there&rsquo;s a few articles on roguebasin - one of which I&rsquo;ve read many times over the years, and never understood a word of it. Pascal is a goofy, blunt looking language and really makes you appreciate how nice programming languages read these days. Or, maybe I&rsquo;m just dense and don&rsquo;t get it. I love that article though - not only because it references my favorite roguelike ADOM(which, despite playing for over a decade have never beat), but because of the word &ldquo;elegant.&rdquo; It just sounds so, appealing.
I sat down, notebook ready, to try and break this article in pieces and figure out what it&rsquo;s saying. The very first thing it says is:
 Readers should be familiar with a linked list (next) and doubly-linked list (prev and next). A circular list simply means that the last object&rsquo;s &ldquo;next&rdquo; points to the first object; and in a doubly-linked circular list the first object&rsquo;s &ldquo;prev&rdquo; points to the last object. The advantage of a circular list over a regular list is that a circular list need not cater for null-references during insertion or deletion of objects.
 Well, my severe lack of formal computer science education meant that I had no idea what any of those things are, really, beyond the fact that they exist and there is likely an STL implementation of those I could find. Searching google for &ldquo;linked list C++&rdquo; led me to this fantastic site.
I decided to take a step back from this project at this point and learn all about lists.
                
                  <br/>
                  <a href="/posts/2018-07-10-the-roguelike-tutorial-week3b/">
                    [Read more]
                  </a>
                
            </p>
        </div>
    
        <div class="list-article">
            <hr class="list-break" \>
            
            <div class="list-title"><a href="/posts/2018-07-02-the-roguelike-tutorial-week3/">The Roguelike Tutorial - Week 3a</a></div>
            
                <span class="list-author">Zach Wilder</span>
            
            
                <span class="list-date"> - 2 Jul 2018</span>
            
            <p class="list-summary">
            I decided to split the third week into two separate posts so that I wouldn&rsquo;t ramble on as long as last week. Over the past week I continued fighting the BSP dungeon generator I had attempted to write the week prior, and gave up again. I&rsquo;ll probably revisit the dungeon generator later, and will definitely write something about whatever I end up doing. The artificial deadlines imposed by following along with the rest of r/roguelikedev really helps motivate me to call something &ldquo;good enough&rdquo; and move on&hellip; Heck, I think I could be satisfied just tinkering with dungeon generators and never moving on to actually making this a playable game!
I did some reading on writing clean C++ by google, which prompted me to take another look at the code I&rsquo;ve already written. The big thing I gleaned from the Google article was to avoid &ldquo;in-lining&rdquo; things in headers, and put most of the code in the implementation. This is something I thought I did already, but apparently using non-trivial types inline in headers is bad for performance. This means stuff like this is OK:
class Foo { public: ... const int &amp; count() { return count_; } ... private: int count_; };  However, doing this is not: class Bar { public: ... Foo badFunc() { return data_; } ... private: Foo data_; }; 
Along the same lines, Google recommends not to inline constructors/destructors with non-trivial types. This is something I did in almost every header file in the game! Fortunately, since this program is still relatively small, the changes to my code were easy enough to implement.
So the first challenge for this week was to implement a &ldquo;field of view&rdquo; for our dungeon delving barbarian. Two options I considered for this were following along with the original Rogue or using Bresenham&rsquo;s line drawing algorithm. The original Rogue showed the entirety of whichever room the player was in, and kept track of explored areas. Field of view using line drawing basically illuminates a radius around the player, while intelligently stopping sight from passing through walls and other obstructions.
                
                  <br/>
                  <a href="/posts/2018-07-02-the-roguelike-tutorial-week3/">
                    [Read more]
                  </a>
                
            </p>
        </div>
    
        <div class="list-article">
            <hr class="list-break" \>
            
            <div class="list-title"><a href="/posts/2018-06-25-the-roguelike-tutorial-week2/">The Roguelike Tutorial - Week 2</a></div>
            
                <span class="list-author">Zach Wilder</span>
            
            
                <span class="list-date"> - 25 Jun 2018</span>
            
            <p class="list-summary">
            So this week&rsquo;s goal is to finish part 2 and part 3 of the tutorial - I worked ahead because I was excited to get this project going, which worked out well since shortly after finishing part 2 I switched to SDL from SFML and it gave me some time to work on this blog.
The Switch to SDL So the game logic is completely divorced from the rendering system - I don&rsquo;t want to be tied into using a set framework if I want to change later, and I know for a fact from previous projects this will make save files much easier to generate. I briefly described last week that the game has a virtual console that is written to, and is read/translated into graphics to be displayed by SFML. Well, the console is a grid of say, 80x50 (960px x 600px). Each cell in the grid has a glyph that needs to be translated and rendered. During engine initialization, it loads one texture (image) as the spritesheet - in this case it&rsquo;s a .png image of the CP437 font.
  Now what Engine::Draw() did originally was make a new SFML sprite for each cell, with the position set to the font size multiplied by the cell x,y coordinates. Seemed simple enough, and it worked - but that&rsquo;s 4000 sprites created and destroyed EVERY time Draw() is called. The next iteration created two arrays of sprites in Engine::Init() that were persistent and lived throughout the life of the program - one sprite for each cell in an array, and one for each glyph. Then, in draw, each cell&rsquo;s sprite was just changed to be the same value as the sprite representing the glyph on the console. Yep, that worked too, but it still seemed there had to be a cleaner, better way of doing this.
I realized something shortly after finishing that, I don&rsquo;t need all those sprites. I could just create an array of rectangles representing the sprite location on the texture and then change each cell&rsquo;s sprite location in that array! Further, doing this I didn&rsquo;t really need 4000 sprites (one for each cell) - couldn&rsquo;t I just use one sprite, updating it&rsquo;s position and rectangle before drawing it, since I only clear the render surface before drawing the first time?
                
                  <br/>
                  <a href="/posts/2018-06-25-the-roguelike-tutorial-week2/">
                    [Read more]
                  </a>
                
            </p>
        </div>
    
        <div class="list-article">
            <hr class="list-break" \>
            
            <div class="list-title"><a href="/posts/2018-06-20-the-roguelike-tutorial-week1/">The Roguelike Tutorial - Week 1</a></div>
            
                <span class="list-author">Zach Wilder</span>
            
            
                <span class="list-date"> - 20 Jun 2018</span>
            
            <p class="list-summary">
            Last year r/roguelikedev did a really cool thing with a weekly post where everyone followed along with a tutorial, shared ideas and problems, and motivated each other to actually finish a project. Well they&rsquo;re doing it again this year, and with the announcement last week I decided to take a look at the new and improved, Python3 version of the tutorial.
For those not familiar with this famous tutorial - each part covers a small chunk of building a roguelike using simple language and easy to follow code. In just 13 parts you have a working roguelike to build off of and branch out from. A really, really cool idea. I did the old Python2 version a couple years back, and it blew my mind. After completing the last part I finally had made a game, and was pretty proud of the results. I didn&rsquo;t know Python when I started, and hadn&rsquo;t done any coding before beginning, but was able to follow along and even add my own stuff along the way. Eventually, my lack of knowledge caught up with me and my bloated single file Python program started to become difficult to modify and maintain. I took a step back, and decided to start relearning C and then ventured into C++.
I quickly found that I actually really enjoy more of the building of the game than the designing of the game. Which, is cool because the amount of things to build and the resources available for building things from scratch are darn near infinite - especially with the knowledge of the internet at my fingertips. It is not, however, conducive to finishing a project or making something playable.
As I read through the new and improved tutorial, I realized something pretty amazing: I could build this in C++. Reading each part I could think of ways (plural!) that I could accomplish the same thing, but with my own code. So, I decided to play along with the tutorial, and force myself to follow the deadlines - a week for each part.
I decided to start posting this to the blog after I had finished Parts 0 - 3, which covers weeks one and two - so I&rsquo;ve written a brief summary of what I&rsquo;ve done in parts 1 and 2 of the tutorial so far.
                
                  <br/>
                  <a href="/posts/2018-06-20-the-roguelike-tutorial-week1/">
                    [Read more]
                  </a>
                
            </p>
        </div>
    
</main>

  <footer>
  

  
  <hr/>
  © <a href="/about/">Z Wilder</a> 2016-2023 | <a href="https://github.com/zwilder/">Github</a>
  
  </footer>
  <div id="ltbox">
    <p>[Click Anywhere To Close]</p>
    <div id="content">
        <img src="#">
    </div>
</div>

  </body>
</html>

