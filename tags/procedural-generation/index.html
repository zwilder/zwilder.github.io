<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Procedural Generation | Wsl Blog</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    <link rel="icon" type="image/svg+xml" href="/wsl.svg" />
    <link href="https://fonts.googleapis.com/css?family=Cinzel+Decorative|Raleway&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Belgrano|Lato&display=swap" rel="stylesheet">



<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>


<script>
jQuery(document).ready(function($) {
    
        
    
    $('.ltbox-trigger').click(function(e) {
    	
        
		e.preventDefault();
		
		
		var image_href = $(this).attr("href");
		
		

		
		if ($('#ltbox').length > 0) { 
			
			
			$('#content').html('<img src="' + image_href + '" />');
		   	
			
			
            
            $('#ltbox').toggle();
		}
		
        return false;
    });
    $('body').on('click', '#ltbox', function() { 
        
        $('#ltbox').toggle();
    });
});
</script>

  </head>

  <body>
      <div class="site-title">
          <img class="wsl-logo" src="/wsl.svg" />
          <span class="wsl-title">
             Wsl Blog
          </span>
      </div>
    <nav>
    <p class="sub-title">Adventures in making, arting, exploring, and other things.</p>
    <div class="menu">
        <ul>
          
              <li><a href="/">Home</a></li>
          
              <li><a href="/posts/">Archive</a></li>
          
              <li><a href="/categories/">Categories</a></li>
          
              <li><a href="/tags/">Tags</a></li>
          
              <li><a href="/subscribe/">Subscribe</a></li>
          
              <li><a href="/index.xml">RSS</a></li>
          
        </ul>
    </div>
    <hr/>
    </nav>


<div class="article-meta">
    <div class="title"><span>Procedural Generation</span></div>
</div>
    <hr/>
<main>
    

    
        <div class="list-article">
            
            
            <div class="list-title"><a href="/posts/2023-11-17-markov/">Markov Chain Word Generator</a></div>
            
                <span class="list-author">Zach Wilder</span>
            
            
                <span class="list-date"> - 17 Nov 2023</span>
            
            <p class="list-summary">
            The first screen the player sees in Goblin Caves is a black screen with a question and a prompt.
    This &ldquo;new player&rdquo; screen was originally made as a &ldquo;quick and dirty&rdquo; sort of thing, with the intention of replacing it with something fancier - or at least more flashy. It&rsquo;s really grown on me since I originally wrote it, and I don&rsquo;t think I&rsquo;m going to change it. What does still bother me though, is that if you just hit enter without putting down something a little message box pops up, asking you to &ldquo;Please try again.&rdquo;
    That&rsquo;s kinda lame, and directly above the code that does that error checking (was) a comment I wrote to myself: &ldquo;It would be super cool if this was replaced with a call to a random name generator&hellip;&rdquo;
Well I came across that comment while rewriting all the drawing and input handling code, and decided that was going to be my next project.
Random words are typically not just random characters slapped together - that would just give words like:
 alxvik hhbatxr orikumo kxzzmk cafzrx jkiuvfm
 Not very satisfying, right? Are those names? Places? Plants? Weapons? Who knows. To get more satisfying words, a better approach is to use a Markov Chain - what Wikipedia defines cryptically as &ldquo;a stochastic model describing a sequence of possible events in which the probability of each event depends only on the state attained in the previous event.&rdquo;
That&rsquo;s just a bunch of fancy words to say (in this context) that if you start with a sequence of letters, which next letter is most likely to occur?
If you know those probabilities, word generation becomes easy - start with a few letters, figure out what letter could come next, choose one of those letters and start the process over with that letter and the preceding letters. With any dataset input, the words that would be generated following these probabilities would (should) be very similar to the input. I could even take multiple datasets, generate some words, handpick words I like for another dataset, and then generate a whole bunch of words similar to the ones I like!
                
                  <br/>
                  <a href="/posts/2023-11-17-markov/">
                    [Read more]
                  </a>
                
            </p>
        </div>
    
        <div class="list-article">
            <hr class="list-break" \>
            
            <div class="list-title"><a href="/posts/2017-01-07-gradients-and-actions/">Gradients for Colors, and Actions for Actors</a></div>
            
                <span class="list-author">Zach Wilder</span>
            
            
                <span class="list-date"> - 7 Jan 2017</span>
            
            <p class="list-summary">
            Over the past couple of weeks I&rsquo;ve been working on simplifying the code for my roguelike project - heavily inspired by one of my favorite books on my shelf, Game Programming Patterns.
I&rsquo;ve seriously read this book cover to cover, multiple times - and every time find a new use for one of the &lsquo;patterns&rsquo; in it. I just discovered that the author&rsquo;s blog has a bunch of good reads on it as well. One of the biggest problems I&rsquo;ve had with the roguelike project was a simple way to issue commands (which should have been a clue) from the player to the character, and from the computer AI to the enemies.
The first chapter in the book, and this blog post had the answer - the &lsquo;Command&rsquo; pattern. I have no idea how I didn&rsquo;t think of this sooner - basically, all the actions that an actor (player or enemy) can take are issued as &lsquo;commands&rsquo;. A command is just a subclass of an action, and each actor when updating gets to call it&rsquo;s most current action&rsquo;s perform() routine. What makes this super cool and useful is that the perform routine returns an ActionResult, which has a flag stating whether or not the current action was successful, and a suggested alternate action (for use if the action was unsuccessful).
class Action { public: virtual ActionResult perform(Actor &amp; actor) = 0; protected: Action() { } }; class ActionResult { public: ActionResult() { status_ = true; } bool success() { return status_; } void setFalse() { status_ = false; } void setTrue() { status_ = true; } Action * getAlternate() { return alternative_; } void setAlternate(Action * alternate) { alternative_ = alternate; } private: Action * alternative_; bool status_; };  Now, if the player moves into a square - instead of the keypress moving the player, the keypress just sets the player&rsquo;s next action to attack in the direction of that tile. During the players update, the perform() for the attack action checks to see if there is another actor there - and if there isn&rsquo;t returns a move action as an alternate.
                
                  <br/>
                  <a href="/posts/2017-01-07-gradients-and-actions/">
                    [Read more]
                  </a>
                
            </p>
        </div>
    
        <div class="list-article">
            <hr class="list-break" \>
            
            <div class="list-title"><a href="/posts/2016-12-20-automata-caves/">Randomly Generated Caves with Cellular Automata</a></div>
            
                <span class="list-author">Zach Wilder</span>
            
            
                <span class="list-date"> - 22 Dec 2016</span>
            
            <p class="list-summary">
            So, every time I get the urge to write a blog post about whatever random bit of code I&rsquo;m writing - I look at the blog and think: &ldquo;Hm, this is kinda ugly.&rdquo; Then, I have to rewrite it until I&rsquo;m mostly satisfied with how it looks.
Recently, I&rsquo;ve been working on writing a nice little interface for handling menus and other parts of the UI for my roguelike project. Unfortunately, like the layout of this blog, I can&rsquo;t seem to find a satisfactory &lsquo;look and feel&rsquo; - I think I&rsquo;ve got a good start though.
While procrastinating working on that, I&rsquo;ve spent a lot of time thinking about the map, and my ECS system. At the risk of prematurely optimizing code, it seems like an awful waste of space to make every tile an entity. Most of a tiles properties are simple boolean flags anyways, so why not make tiles just a bitflag and glyph to represent them? After running some halfassed tests on this idea, the size of an entire map (100x100, or 10,000 tiles) worth of tiles was a mere 24 bytes. Yeah, this idea will work just fine.
Basically, how it works now is a tile is just: struct Tile { int bitMask; char glyph; } 
And the flags: enum TileFlags : int { NONE = 0, BLOCKS_MOVEMENT = 0x001, BLOCKS_LIGHT = 0x002, UP_STAIR = 0x004, DOWN_STAIR = 0x008, DOOR = 0x010, FLOOR = 0x020 }; 
I&rsquo;m a pretty huge fan of bitflags, mostly because it allows me to do all sorts of cool stuff. Say for instance we added a LIQUID flag to TileFlags - liquid blocks movement (our fearless adventurer never took swim lessons, apparently) but doesn&rsquo;t block light, so the adventurer&rsquo;s field of vision would see over the murky pool of whatever liquid.
But wait! It gets better, what if our adventurer decides that, while standing next to a murky pool of water, to read a Scroll of Explosion - The game logic can now easily test to see if any of the affected tiles are also liquid, and make steam that the player CAN&rsquo;T see through!
                
                  <br/>
                  <a href="/posts/2016-12-20-automata-caves/">
                    [Read more]
                  </a>
                
            </p>
        </div>
    
</main>

  <footer>
  

  
  <hr/>
  © <a href="/about/">Z Wilder</a> 2016-2023 | <a href="https://github.com/zwilder/">Github</a>
  
  </footer>
  <div id="ltbox">
    <p>[Click Anywhere To Close]</p>
    <div id="content">
        <img src="#">
    </div>
</div>

  </body>
</html>

